# study record mark

后端框架选择 Egg.js + Typescript

数据库选择 MongoDB 到 mongoose

### 技术方案设计 - 接口设计
**技术方案设计的重要性**

**功能拆分**
*用户系统*
  * 注册

  * 登录

* 作品管理

* 模板

* 渠道

* 工具类
  * 上传图片
  * 预览以及展示作品

**要特别留意的问题：权限**

* 第一层级  登录用户
* 第二层级  只能更新或删除自己的资源
* 第三层级  只能更新特定的字段
* 第四层级  管理员

#### 第二步 从需求提取接口 ####
** RESTFUL api 格式**
* 路径 -Endpoint 
> 每个网址代表一种资源 resource 正好可以和我们的需求分类的这几种实体相对应

* 动词 - verb
> 对于资源的具体操作类型 由http 动词表示
* GET (select) 从服务器取资源 一项或多项
* POST(CREATE) 在服务器创建资源
* PUT(UPDATE) 服务器更新资源 客户端提供完整资源
* PATCH(UPDATE) 更新资源  客户端提供改变的属性
* DELETE(DELETE) 删除资源 从服务器删除资源

#### 返回参数 ####
```json
{
  errno:0, // 错误码
  data:{...},
  message:'xxxx'
}
```

## express ##
**快速 无限制**
#### 中间件 ####
*线性*

#### Koa2 ####
* 使用 Promise 代替 callback
* 使用 ctx 上下文封装 req 和 res
*  **完全不同的中间件机制**
* 更轻量

***koa2***
* 洋葱模型
* 太轻量级
* 没有约束 对于统一维护和开发非常不利

**egg.js**

#### 对于后端框架的需求 ####
* 需要统一的约定
* 丰富的扩展性
* 对typescript 支持
* 约定优于配置

三层架构模式

* Router

* Controller 控制器  输入  输出

* Service服务：对复杂业务的封装
* 保持controller简洁
* 保持业务逻辑的独立性
* 将逻辑和展示分离
*使用场景*
查数据库
第三方api

#### next.js ####

* class 装饰器用的比较多

curl -X POST http://localhost:7002/test --data '{"name":"yuex","hobby":"soccer"}' --header 'Content-Type:application/json; charset=UTF-8'


plugin 增加页面功能


middleWare  洋葱模型


数据  

关系型数据库  
字段先定义好了
稳定  难扩展


非关系性数据库

灵活的数据模型

horizontal scaling  横向扩展
文档储存  MongoDB
key value  Redis
图存储  Neo4J

技术选型

大量可变的非结构数据



# 前端监控 #
**为什么需要前端监控**
页面访问行为 PV
用户操作行为  模块曝光  模块点击
页面性能 监控  首页渲染时间 API 请求时间
异常监控 js error  API异常 页面异常
业务监控  成交金额 消息数

### 自建监控平台 ###

*流量监控*


### 前端监控平台架构设计 ###

***监控平台分层***
采集
上报
默认上报：页面pv 性能
手动上报 页面操作行为

**前端监控API和大数据仓库**
接收上报数据
数据仓库 MaxComputer

**数据可视化**

数据清洗
大数据回流RDS
结构化进行计算 图表



#### 前端sdk开发 ####

浏览器的监听api
MutationObserrver

IntersectionObServer

PreformanceObserver

ResizeObserver

ReportingObserver

***
### 浏览器 ###

1. url 请求页面
2. 解析html 构建dom树
3. 计算dom树上的css属性
4. 根据css属性 对元素逐个渲染 得到内存中位图 有点像vdom 虚拟dom
5. 对位图进行合成 极大地增加后续绘制速度 可选步骤 相当于做些优化合并
6. 合成之后 绘制到界面

#### dom 解析 ####
分词 token 最小的有意义单元
从http协议收到字符流读取字符
每读取一个字符就要进行一次决策
状态机
***
**构建dom树是使用栈来实现的**

***浏览器会尽量的流式处理整个过程***

***css选择器 叫做css匹配器更符合***

*css选择器的一个特点*
选择器出现的顺序 必定跟构建dom树的顺序一致
css的设计规则
**保证dom树构建到当前节点时已经可以准确的判断是否匹配 不需要后续节点信息**

css 需要经过词法分析 和 语法分析 变成计算机能够理解的结构

**render 把模型变成位图过程**

*从数据变成 HTML 代码的过程*

位图是在内存中建立一张二维表格
位图信息也是dom树中占据浏览器内存最多的信息

***盒其实时模型 要变成位图***

盒的背景  边框  SVG元素 阴影都是需要绘制的
图形类  需要底层库支持
操作系统会提供底层库 android SKia Windows有GDI


**合成**
compositing
为一些元素创建一个合成后的位图

will-change 属性

***绘制是把位图绘制到屏幕，变成肉眼可见的图像 浏览器并不需要用代码来处理这个过程  只需将位图交给操作系统***


**绘制发生的频率比我们想象的要高的多**

鼠标划过浏览器的显示区域 都会造成重绘 不重新绘制会
产生大量的残影

**计算机图形学 脏矩法 把屏幕分成若干矩形区域**


**dom api 文档对象模型**
1. 节点 dom树形结构
2. 事件 触发和监听相关api
3. Range 操作文字范围相关api
4. 遍历 遍历dom需要的API

**DOM对象模型**
html在内存中的dom对象模型 js操作dom对象模型

***dom语义 css表现***

*CSSOM  css模型部分和css View部分*


**滚动分为视口滚动和浏览器滚动**

*视口滚动是容器顶层的滚动 大部分浏览器会做优化*

**元素没有宽高的概念**

**元素所对应的盒 getClientRects() getBoundingClientRect()**


**键盘 鼠标 触摸屏**
鼠标 触摸屏称为pointer
现代的UI系统 都源自WIMP window icon Menu  Pointer

施乐公司开发的

我们能点击按钮其实不对  能点击鼠标按钮  触摸屏 操作系统和触摸屏把信息对应到这个逻辑按钮

**把坐标转化具体元素上的过程 成为捕获**

**捕获是计算机处理事件的逻辑，冒泡是人类处理事件的逻辑**

#### 键盘事件由焦点控制 ####
*操作系统会有一套焦点系统*
*现代浏览器也会有自己的焦点系统覆盖操作系统*












